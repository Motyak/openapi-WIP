# coding: utf-8

"""
    Spotify Web API with fixes and improvements from sonallux

    You can use Spotify's Web API to discover music and podcasts, manage your Spotify library, control audio playback, and much more. Browse our available Web API endpoints using the sidebar at left, or via the navigation bar on top of this page on smaller screens.  In order to make successful Web API requests your app will need a valid access token. One can be obtained through <a href=\"https://developer.spotify.com/documentation/general/guides/authorization-guide/\">OAuth 2.0</a>.  The base URI for all Web API requests is `https://api.spotify.com/v1`.  Need help? See our <a href=\"https://developer.spotify.com/documentation/web-api/guides/\">Web API guides</a> for more information, or visit the <a href=\"https://community.spotify.com/t5/Spotify-for-Developers/bd-p/Spotify_Developer\">Spotify for Developers community forum</a> to ask questions and connect with other developers. 

    The version of the OpenAPI document: 2023.8.30
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import List, Optional
from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
from openapi_client.models.external_url_object import ExternalUrlObject
from openapi_client.models.followers_object import FollowersObject
from openapi_client.models.image_object import ImageObject
from openapi_client.models.paging_playlist_track_object import PagingPlaylistTrackObject
from openapi_client.models.playlist_owner_object import PlaylistOwnerObject

class PlaylistObject(BaseModel):
    """
    PlaylistObject
    """
    collaborative: Optional[StrictBool] = Field(None, description="`true` if the owner allows other users to modify the playlist. ")
    description: Optional[StrictStr] = Field(None, description="The playlist description. _Only returned for modified, verified playlists, otherwise_ `null`. ")
    external_urls: Optional[ExternalUrlObject] = None
    followers: Optional[FollowersObject] = None
    href: Optional[StrictStr] = Field(None, description="A link to the Web API endpoint providing full details of the playlist. ")
    id: Optional[StrictStr] = Field(None, description="The [Spotify ID](/documentation/web-api/concepts/spotify-uris-ids) for the playlist. ")
    images: Optional[conlist(ImageObject)] = Field(None, description="Images for the playlist. The array may be empty or contain up to three images. The images are returned by size in descending order. See [Working with Playlists](/documentation/web-api/concepts/playlists). _**Note**: If returned, the source URL for the image (`url`) is temporary and will expire in less than a day._ ")
    name: Optional[StrictStr] = Field(None, description="The name of the playlist. ")
    owner: Optional[PlaylistOwnerObject] = None
    public: Optional[StrictBool] = Field(None, description="The playlist's public/private status: `true` the playlist is public, `false` the playlist is private, `null` the playlist status is not relevant. For more about public/private status, see [Working with Playlists](/documentation/web-api/concepts/playlists) ")
    snapshot_id: Optional[StrictStr] = Field(None, description="The version identifier for the current playlist. Can be supplied in other requests to target a specific playlist version ")
    tracks: Optional[PagingPlaylistTrackObject] = None
    type: Optional[StrictStr] = Field(None, description="The object type: \"playlist\" ")
    uri: Optional[StrictStr] = Field(None, description="The [Spotify URI](/documentation/web-api/concepts/spotify-uris-ids) for the playlist. ")
    __properties = ["collaborative", "description", "external_urls", "followers", "href", "id", "images", "name", "owner", "public", "snapshot_id", "tracks", "type", "uri"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> PlaylistObject:
        """Create an instance of PlaylistObject from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of external_urls
        if self.external_urls:
            _dict['external_urls'] = self.external_urls.to_dict()
        # override the default output from pydantic by calling `to_dict()` of followers
        if self.followers:
            _dict['followers'] = self.followers.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in images (list)
        _items = []
        if self.images:
            for _item in self.images:
                if _item:
                    _items.append(_item.to_dict())
            _dict['images'] = _items
        # override the default output from pydantic by calling `to_dict()` of owner
        if self.owner:
            _dict['owner'] = self.owner.to_dict()
        # override the default output from pydantic by calling `to_dict()` of tracks
        if self.tracks:
            _dict['tracks'] = self.tracks.to_dict()
        # set to None if description (nullable) is None
        # and __fields_set__ contains the field
        if self.description is None and "description" in self.__fields_set__:
            _dict['description'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> PlaylistObject:
        """Create an instance of PlaylistObject from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return PlaylistObject.parse_obj(obj)

        _obj = PlaylistObject.parse_obj({
            "collaborative": obj.get("collaborative"),
            "description": obj.get("description"),
            "external_urls": ExternalUrlObject.from_dict(obj.get("external_urls")) if obj.get("external_urls") is not None else None,
            "followers": FollowersObject.from_dict(obj.get("followers")) if obj.get("followers") is not None else None,
            "href": obj.get("href"),
            "id": obj.get("id"),
            "images": [ImageObject.from_dict(_item) for _item in obj.get("images")] if obj.get("images") is not None else None,
            "name": obj.get("name"),
            "owner": PlaylistOwnerObject.from_dict(obj.get("owner")) if obj.get("owner") is not None else None,
            "public": obj.get("public"),
            "snapshot_id": obj.get("snapshot_id"),
            "tracks": PagingPlaylistTrackObject.from_dict(obj.get("tracks")) if obj.get("tracks") is not None else None,
            "type": obj.get("type"),
            "uri": obj.get("uri")
        })
        return _obj


